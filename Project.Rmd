---
title: "STAT 221 Project"
author: "John Rapp Farnes | 405461225"
date: "3/5 2020"
output:
  pdf_document: default
  html_document: default
---

# Questions
- What to do with missing values? Skip them? Linea interpolate?
- What to do with residuals?

- Is it stationary?
- auto.arima vs sarima

# TODO
- AIC comparison
- Look at difference

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(astsa)
library(imputeTS)
library(rjson)
library(forecast)

data <- fromJSON(file = "./mammoth.json")
plot(data$depth, type="o")
```

```{r}
data$dates <- as.Date(data$dates, "%Y-%m-%d")

all_dates <- seq(data$dates[1], data$dates[length(data$dates)], by = "day")

length(data$dates) / length(all_dates)

all_depths <- rep(NA, length(all_dates))

for (date in intersect(data$dates, all_dates)) {
  all_depths[which(all_dates == date)] <- data$depth[which(data$dates == date)[1]]
}
```

```{r}
table(as.numeric(format.Date(data$date, "%m")), data$depth == 0)

all_depths[which(all_depths == 0)] <- NA
```

```{r}

data <- data.frame(date = all_dates, depth = all_depths)

nrow(data)

plot(data, type="o")
```

```{r}
(tab <- table(as.numeric(format.Date(data$date, "%m")), is.na(data$depth)))

plot(tab[, 1] / (tab[, 1] + tab[, 2]), type="o")
```

```{r}

mean_ignore_na <- function(x) {
  non_na <- x[which(!is.na(x))]
  return(ifelse(length(non_na) == 0, NA, mean(non_na)))
}

first_sat <- 3
last_sat <- length(data$date) - 3

week_length <- 7
nr_weeks <- (last_sat - first_sat) / week_length

week_start <- data$date[first_sat]
week_end <- data$date[last_sat]

weekly_depths <- mean_ignore_na(data$depth[1:first_sat])

# for(i in seq(from = first_sat, to = last_sat, by = week_length)) {
for (i in 2:(nr_weeks + 1)) {
  sunday <- (first_sat + 1) + (i - 2)*week_length
  saturday <- sunday + 6

  weekly_depths[i] <- mean_ignore_na(data$depth[sunday:saturday])
}

weeks <- seq(data$date[first_sat], data$date[last_sat], by=7)

data <- data.frame(
  depth = weekly_depths,
  date = weeks
)

plot(data$depth, type="o")


# format(date, "%U")

# as.numeric(format(data$date, "%U"))

# data$date[which(as.numeric(format(data$date, "%U")) == 52)]
# format(data$date[which(as.numeric(format(data$date, "%U")) == 52)], "%a")

# aggregate(data$depth,
#           list(week = as.numeric(format(data$date, "%U"))),
#           function(x) {
#             print(length(x))
#             return("hej")
#           })
```

```{r}
series <- ts(
  data$depth,
  start=c(as.numeric(format(data$date[1], "%Y")), as.numeric(format(data$date[1], "%U"))),
  # end=c(as.numeric(format(data$date[length(data$date)], "%Y")), as.numeric(format(data$date[length(data$date)], "%U"))),
  frequency=365.25/7
)
plot(series)
```


# ACF
```{r}
acf(na_interpolation(series, option = "linear"), lag.max = 52 * 2)
pacf(na_interpolation(series, option = "linear"), lag.max = 52 * 2)
```

# Detrend
```{r}
model <- lm(series ~ time(series))
summary(model)

plot(series)
lines(series*0 + predict(model, time(series)), type="l", col="red")

detrended <- series - predict(model, time(series))

plot(detrended)
```

```{r}
sum(is.na(data$depth) / length(data$depth))

(tab <- table(as.numeric(format.Date(data$date, "%m")), is.na(data$depth)))

plot(tab[, 1] / (tab[, 1] + tab[, 2]), type="o")


plot(detrended)
detrended <- na_interpolation(detrended, option = "linear")
plot(detrended)
```

```{r}
plot(diff(detrended))
acf(diff(detrended), lag.max = 52 * 2)
pacf(diff(detrended), lag.max = 52 * 2)
```


# Periodogram

```{r}
pg <- mvspec(detrended, log="no")

k = kernel("modified.daniell", c(3,3))
pg <- mvspec(soi, kernel=k, taper=.1, log="no")

max_index <- which(pg$spec == max(pg$spec))
freq <- pg$freq[max_index]

1/freq

plot(pg$freq, pg$spec, type="l")
abline(v=freq, col="blue")


max_index2 <- which(pg$spec == max(pg$spec[which(pg$freq < 0.5)]))
freq <- pg$freq[max_index2]

1/freq
abline(v=freq, col="red")

max_index3 <- which(pg$spec == max(pg$spec[which(pg$freq > 1.5)]))
freq <- pg$freq[max_index3]

1/freq
abline(v=freq, col="green")

max_index4 <- which(pg$spec == max(pg$spec[which(pg$freq > 2.5)]))
freq <- pg$freq[max_index4]

1/freq
abline(v=freq, col="yellow")
```


# ACF
```{r}
acf(detrended, lag.max = 52 * 2)
pacf(detrended, lag.max = 52 * 2)
```

# Fit ARIMA

```{r}
# auto.arima(detrended)
# ARIMA(2,0,1)(1,1,0)[52]

# Coefficients:
#          ar1      ar2      ma1     sar1
#       1.7781  -0.7911  -0.5474  -0.5192
# s.e.  0.0679   0.0666   0.0923   0.0433
# 
# sigma^2 estimated as 148.9:  log likelihood=-1489.99
# AIC=2989.98   AICc=2990.14   BIC=3009.65

sarima(detrended, 2,0,1, 1,1,0, 1)
sarima(detrended, 2,0,1, 1,1,1, 1)
```
```{r}
models <- list(
  arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,0), period=52)),
  # arima(detrended, order=c(2,1,1), seasonal=list(order=c(1,1,0), period=52))#,
  # arima(detrended, order=c(3,1,2), seasonal=list(order=c(1,1,0), period=52))#,
  arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,1), period=52)),
  arima(detrended, order=c(2,0,1), seasonal=list(order=c(0,1,1), period=52))#,
  # arima(detrended, order=c(3,1,2), seasonal=list(order=c(2,1,1), period=52))
)

models

lapply(models, function(x) {
  return(x$aic)
})
```



```{r}
best_model <- models[[2]]
fore <- predict(best_model, n.ahead=52 * 10)

first_date <- time(series)[1]
last_date <- time(series)[length(time(series))]

ts.plot(detrended, fore$pred, col=1:2, xlim=c(first_date,last_date + 10 / 52), ylab="Forecast")

# ts.plot(detrended, fore$pred, col=1:2, ylab="Forecast")
U = fore$pred+fore$se; L = fore$pred-fore$se
xx = c(time(U), rev(time(U))); yy = c(L, rev(U))
polygon(xx, yy, border = 8, col = gray(.6, alpha = .2))
lines(fore$pred, type="p", col=2)

for (y in 0:8) {
  abline(v = last_date - y, lty="dashed", col="gray")
}


```


# Show residuals and measure of how well fit

# Comment on fitted model

# Estimate the spectral density using the periodogram and smoothed periodogram. 

# Comment on any clear cycles and the overall distribution of the variance by frequency, and its relationship to the smoothness of your time series
