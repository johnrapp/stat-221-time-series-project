---
title: "STAT 221 Final Project - Mammoth Snow Depth"
author: "John Rapp Farnes | 405461225"
date: "3/17 2020"
output:
  pdf_document:
    toc: true
    number_section: true
---

% TODO
- Prediction på known värden
- Tillbaka trend på pred

- Kommentera stora residualer? datum?
- Log: större skillnad större värden, plotta
- Periodogram residualer
- Tapering


```{r setup, include = F}
knitr::opts_chunk$set(echo = F)
```

# Introduction

## Background

Mammoth is a mountain in Northern California know for its great alpine ski and snowboarding conditions. For this purpose, the mountain features a ski resort with the same name. This resort has has more than 3,500 acres of ski-able terrain and is serviced by 28 lifts and recieves over 1 million anuual visitors. For Southern Californian residents, the mountain is of interest as it is one of the closest "good" ski resorts, about a 4-6 hour drive away from Los Angeles. \ref{mammoth_about}

As people familiar with alpine sports know, one of the most important conditions for the sport is the snow depth at the mountain, as this affects which runs are open and how "good" the skiing is. As such, the purpose of this report is to **model the weekly snow depth at Mammoth mountain in order to make predictions on future skiing conditions**.

## Data set
Data on historic snow depth at Mammoth were obtained from the reporting of Mammoth Mountain Ski Area, through a third party website \ref{mammoth_data}. The website does not give the data easily in a downloadable form, hence the data was obtained through injecting JavaScript into a browser client that took the data from the browser JavaScript enviroment and printed it in a PDF format. This raw data is shown in figure \ref{fig:raw_data}, featuring 1791 recordings from 2011-12-01
through 2020-03-02 of daily snow depth measured in incehs. Opon looking at the graph, two issues with the raw data are found: 1) The dates in the off-season (outside of the winter months) are not included, rather the years are concatinated together in a single time-frame 2) some values within the recorded period are missing and reported as 0. Hence, the data needed to be cleaned.

## Cleaning data
The first step in cleaning the data was to include the missing dates in order to capture the full time-frame of the data. The next step was handling the missing values, both in the off-season as well as the missing recorded values. In order to handle the missing recorded values, as well as to make lower variance predictions on snow depth further in the future than a couple of days, the data was aggregated and averaged (disregarding the missing values) per week, creating a weekly time series. This week was defined as starting a Saturday, as this a day of interest for many weekend skieers. The off-season missing values were replaced by 0s, as this is an accurate description of the snow depth during those months -- there rarely is not snow on Mammoth during the summer. The resulting data after cleaning is shown in figure \ref{fig:cleaned}, featuring 431 weeks. The availability of data per month is displayed in \ref{fig:availability}, showing that data exists for the most part Dec-May, with less than 50% Jun-Oct, reaching ~80% in November.

# Analyis
Looking at the grapth, it is clear that the ski season of 2020 has a far greater snow depth than prior years, an unfortunate fact for skiiers this season. To study other properties than this obvious observation, time-series methods were applied.

## Series properties
First, the properties of the time-series were studies. Figure ref{fig:acf_series} shows the ACF and PACF of the series, where the ACF shows periodic behaviour with length 1 year that tails off, and the PACF has 2 (barely) significant values and then cuts off, implying that a seasonal AR model may be a good description of the series. The 1 year period is easily seen also in the periodogram (figure ref{fig:period_series}), together with a 4 year period, both significant peaks. The 4 year period may be an artifact of the data being recorded for 4 years and these years having a pattern of yearly depth by  chance.

The data does not appear to be stationary as it has an obvious yearly trend, and ARIMA models can not be applied. Hence the data must first be detrended.

## Detrending

## Detrended series properties

## Model fitting

## Model interpretation

## Model evaluation

### Residual analysis

## Frequency domain

## Alternative model

# Results

## Conclusion

## Dicsussion

## Next steps

# Appendix - Figures and graphs

# References

1. https://www.mammothmountain.com/ 




```{r include=F}
library(astsa)
library(imputeTS)
library(rjson)
library(forecast)
library(tseries)

```

```{r fig.cap="\\label{fig:raw_data}Raw Mammoth snow depth data"}
# Read and plot raw data
data <- fromJSON(file = "./mammoth.json")
plot(data$depth, type="o", main="Raw data", ylab="Snow depth (in)")
```

```{r, include=F}
#Fill in missing days
data$dates <- as.Date(data$dates, "%Y-%m-%d")

all_dates <- seq(data$dates[1], data$dates[length(data$dates)], by = "day")

length(data$dates) / length(all_dates)

all_depths <- rep(NA, length(all_dates))

for (date in intersect(data$dates, all_dates)) {
  all_depths[which(all_dates == date)] <- data$depth[which(data$dates == date)[1]]
}
```

```{r, include=F}
table(as.numeric(format.Date(data$date, "%m")), data$depth == 0)

all_depths[which(all_depths == 0)] <- NA
```

```{r, include=F}
data <- data.frame(date = all_dates, depth = all_depths)

nrow(data)

plot(data, type="o")
```

```{r, include=F}
(tab <- table(as.numeric(format.Date(data$date, "%m")), is.na(data$depth)))

plot(tab[, 1] / (tab[, 1] + tab[, 2]), type="o")
```

```{r, include=F}

mean_ignore_na <- function(x) {
  non_na <- x[which(!is.na(x))]
  return(ifelse(length(non_na) == 0, NA, mean(non_na)))
}

first_sat <- 3
last_sat <- length(data$date) - 2

week_length <- 7
nr_weeks <- (last_sat - first_sat) / week_length

week_start <- data$date[first_sat]
week_end <- data$date[last_sat]

weekly_depths <- mean_ignore_na(data$depth[1:first_sat])

# for(i in seq(from = first_sat, to = last_sat, by = week_length)) {
for (i in 2:(nr_weeks + 1)) {
  sunday <- (first_sat + 1) + (i - 2)*week_length
  saturday <- sunday + 6

  weekly_depths[i] <- mean_ignore_na(data$depth[sunday:saturday])
}

weeks <- seq(data$date[first_sat], data$date[last_sat], by=7)

data <- data.frame(
  depth = weekly_depths,
  date = weeks
)

plot(data$depth, type="o")
```

```{r}
data$depth[which(is.na(data$depth))] <- 0
```

```{r fig.cap="\\label{fig:cleaned}Weekly mammoth snow depth data after cleaning"}
series <- ts(
  data$depth,
  start=c(as.numeric(format(data$date[1], "%Y")), as.numeric(format(data$date[1], "%U"))),
  # end=c(as.numeric(format(data$date[length(data$date)], "%Y")), as.numeric(format(data$date[length(data$date)], "%U"))),
  frequency=365.25/7
)
plot(series, main="Cleaned data", ylab="Snow depth (in)")
```
```{r, fig.cap="\\label{fig:availability}Percent of weeks where data was available, per month"}
tab <- table(as.numeric(format.Date(data$date, "%m")), data$depth == 0)

month.labels <- format(ISOdatetime(2000,1:12,1,0,0,0),"%b")
barplot(tab[, 1] / (tab[, 1] + tab[, 2]), names.arg = month.labels, ylab="% available data", main="Available data by month")
```


```{r, fig.cap="\\label{fig:acf_series}ACF and PACF for the cleaned time-series"}
par(mfrow=c(2,1))
plot(acf(series, lag.max = 52 * 2, plot = F), ylim=c(-1,1), xlim=c(0.1,2), main="acf")
plot(pacf(series, lag.max = 52 * 2, plot = F), ylim=c(-1,1), xlim=c(0.1,2), main="pacf")
```

```{r}
plot(diff(series), main="First difference")
plot(diff(series, differences = 2))
acf(diff(series), lag.max = 52 * 2)
pacf(diff(series), lag.max = 52 * 2)

adf.test(series)
```

```{r, fig.cap="\\label{fig:series_period}"}
par(mfrow=c(2,1))
pg <- mvspec(series, log="no")

k = kernel("daniell", c(1,1))
pg <- mvspec(series, kernel=k, log="no")

l <- 1/sum(k$coef^2)

alpha <- 0.05
U = qchisq(alpha/2, 2*l)
L = qchisq(1-alpha/2, 2*l)

max_index <- which(pg$spec == max(pg$spec))
freq <- pg$freq[max_index]

# 1/freq
conf <- l*c(2*pg$spec[max_index]/L,2*pg$spec[max_index]/U)
segments(x0=freq,y0=conf[1],x1=freq,y1=conf[2],col="blue")
segments(x0=freq-0.1,y0=conf[1],x1=freq+0.1,y1=conf[1],col="blue")

# abline(v=freq, col="blue")


max_index2 <- which(pg$spec == max(pg$spec[which(pg$freq < 0.5)]))
freq <- pg$freq[max_index2]

# 1/freq
conf <- l*c(2*pg$spec[max_index2]/L,2*pg$spec[max_index2]/U)
segments(x0=freq,y0=conf[1],x1=freq,y1=conf[2],col="red")
segments(x0=freq-0.1,y0=conf[1],x1=freq+0.1,y1=conf[1],col="red")
# abline(v=freq, col="red")
```

```{r}
# lin.mod <- lm(series ~ time(series))
# summary(lin.mod)
# 
# plot(series)
# lines(series*0 + predict(lin.mod, time(series)), type="l", col="red")
# 
# detrended <- series - predict(lin.mod, time(series))
# 
# plot(detrended)
```

```{r}

periods <- as.numeric(format(data$date, "%V"))
# periods <- as.numeric(format(data$date, "%m"))

agg <- aggregate(
  data$depth,
  by=list(period = periods),
  FUN=mean
)

plot(agg$x, main="Weekly average snow depth", xaxt ="n", type="o", ylab="Snow depth (in)", xlab="")
axis(1, at=1:12, labels=month.labels)


detrended <- data$depth - agg$x[match(periods, agg$period)]

plot(data$depth, type="l", ylim=c(-100, 350))
lines(detrended, type="l", col="red")

detrended <- ts(
  detrended,
  start=start(series),
  end=end(series),
  frequency=frequency(series)
)
plot(detrended, ylab="Snow depth (in)", main="Weekly average snow depth, detrended")
```


```{r}
# sum(is.na(data$depth) / length(data$depth))
# 
# (tab <- table(as.numeric(format.Date(data$date, "%m")), is.na(data$depth)))
# 
# plot(tab[, 1] / (tab[, 1] + tab[, 2]), type="o")
# 
# 
# plot(detrended)
# detrended <- na_interpolation(detrended, option = "linear")
# plot(detrended)
```

```{r}
plot(diff(detrended), main="First difference")
plot(diff(detrended, differences = 2))
acf(diff(detrended), lag.max = 52 * 2)
pacf(diff(detrended), lag.max = 52 * 2)

adf.test(detrended)
adf.test(diff(detrended))
```


```{r}
# TODO konfidens

# pg <- mvspec(detrended, log="no")

k = kernel("daniell", c(2,2))
# pg <- mvspec(diff(detrended), kernel=k, log="no")
pg <- mvspec(detrended, kernel=k, log="no")

l <- 1/sum(k$coef^2)

alpha <- 0.05
U = qchisq(alpha/2, 2*l)
L = qchisq(1-alpha/2, 2*l)

max_index <- which(pg$spec == max(pg$spec))
freq <- pg$freq[max_index]

1/freq
conf <- l*c(2*pg$spec[max_index]/L,2*pg$spec[max_index]/U)
segments(x0=freq,y0=conf[1],x1=freq,y1=conf[2],col="blue")
segments(x0=freq-0.1,y0=conf[1],x1=freq+0.1,y1=conf[1],col="blue")

# abline(v=freq, col="blue")

# 
# max_index2 <- which(pg$spec == max(pg$spec[which(abs(pg$freq - 1) == min(abs(pg$freq - 1)))]))
# freq <- 1
# 
# 1/freq
# conf <- l*c(2*pg$spec[max_index2]/L,2*pg$spec[max_index2]/U)
# segments(x0=freq,y0=conf[1],x1=freq,y1=conf[2],col="red")
# segments(x0=freq-0.1,y0=conf[1],x1=freq+0.1,y1=conf[1],col="red")

```

```{r}
pg <- spec.ar(detrended)

max_index <- which(pg$spec == max(pg$spec))
freq <- pg$freq[max_index]

1/freq
abline(v=freq,col="blue")


max_index2 <- which(pg$spec == max(pg$spec[which(pg$freq > 3)]))
freq <- pg$freq[max_index2]

1/freq
abline(v=freq,col="red")
```



# ACF
```{r}
acf(detrended, lag.max = 52 * 2, main="acf")
pacf(detrended, lag.max = 52 * 2, main="pacf")
```

# Fit ARIMA

```{r}
# auto.arima(detrended)
# ARIMA(2,0,1)(1,1,0)[52]

# Coefficients:
#          ar1      ar2      ma1     sar1
#       1.7781  -0.7911  -0.5474  -0.5192
# s.e.  0.0679   0.0666   0.0923   0.0433
# 
# sigma^2 estimated as 148.9:  log likelihood=-1489.99
# AIC=2989.98   AICc=2990.14   BIC=3009.65

# sarima(detrended, 2,0,1, 1,1,0, 1)
# sarima(detrended, 2,0,1, 1,1,1, 1)


## OFF PEAKS
# Best model: ARIMA(2,1,2)(1,0,0)[52]                    
# 
# Series: detrended 
# ARIMA(2,1,2)(1,0,0)[52] 
# 
# Coefficients:
#          ar1     ar2     ma1      ma2    sar1
#       0.0308  0.5816  -0.082  -0.4565  0.4746
# s.e.  0.1869  0.1543   0.202   0.1653  0.0445
# 
# sigma^2 estimated as 265.3:  log likelihood=-1814.17
# AIC=3640.35   AICc=3640.54   BIC=3664.73

# sarima(detrended, 2,1,2, 1,0,1, 1)
# sarima(detrended, 2,1,2, 1,1,0, 1)

sarima(detrended, 1,1,1)
```

```{r}
models <- list(
  # arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,0), period=52))#,
  
  # arima(detrended, order=c(2,1,2), seasonal=list(order=c(1,0,1), period=52)),
  # # arima(detrended, order=c(2,1,1), seasonal=list(order=c(1,1,0), period=52))#,
  # # arima(detrended, order=c(3,1,2), seasonal=list(order=c(1,1,0), period=52))#,
  # # arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,1), period=52)),
  # # arima(detrended, order=c(3,0,3), seasonal=list(order=c(3,1,3), period=52))
  # # arima(detrended, order=c(2,0,1), seasonal=list(order=c(0,1,1), period=52))#,
  # # arima(detrended, order=c(2,0,1), seasonal=list(order=c(0,1,2), period=52))#,
  # # arima(detrended, order=c(3,1,2), seasonal=list(order=c(2,1,1), period=52)),
  # # arima(detrended, order=c(5,1,2)),
  # arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,0,0), period=52)),
  # arima(detrended, order=c(2,1,1), seasonal=list(order=c(1,0,0), period=52)),
  # arima(detrended, order=c(2,0,1), seasonal=list(order=c(2,0,0), period=52)),
  # arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,0), period=52)),
  # arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,1), period=52)),
  
  # arima(detrended, order=c(2,1,2), seasonal=list(order=c(1,1,0), period=52))#,
  
  arima(detrended, order=c(1,1,1))#,
  
  # arima(detrended, order=c(2,1,1), seasonal=list(order=c(1,0,1), period=52))#,
  # arima(detrended, order=c(5,0,5), seasonal=list(order=c(5,0,5), period=52)),
  # arima(detrended, order=c(5,0,5), seasonal=list(order=c(5,0,5), period=52)),
)

models

lapply(models, function(x) {
  return(x$aic)
})
```



```{r}
best_model <- models[[1]]

weeks_ahead <- 52
fore <- predict(best_model, n.ahead= weeks_ahead)

first_date <- time(series)[1]
last_date <- time(series)[length(time(series))]

ts.plot(detrended, xlim=c(last_date - 52 / 52, last_date + weeks_ahead / 52), ylab="Snow depth (in)", main="Snow depth forecast")
U = fore$pred+fore$se; L = fore$pred-fore$se
xx = c(time(U), rev(time(U))); yy = c(L, rev(U))
polygon(xx, yy, border = 8, col = gray(.6, alpha = .2))
lines(fore$pred, type="o", col=2)

ts.plot(detrended, fore$pred, col=1:2, xlim=c(first_date,last_date + weeks_ahead / 52), ylab="Snow depth (in)", main="Snow depth forecast")

U = fore$pred+fore$se; L = fore$pred-fore$se
xx = c(time(U), rev(time(U))); yy = c(L, rev(U))

polygon(xx, yy, border = 8, col = gray(.6, alpha = .2))
lines(fore$pred, type="p", col=2)

for (y in 0:8) {
  abline(v = last_date - y, lty="dashed", col="gray")
}
```

```{r}
weeks_omit <- 5

ommitted_series <- subset(detrended, start=1, end=length(detrended) - weeks_omit)
best_model <- arima(ommitted_series, order=c(1,1,1))
# best_model <- arima(ommitted_series, order=c(2,0,1), seasonal=list(order=c(1,1,0), period=52))


# plot(detrended, type="l")

weeks_ahead <- 52
fore <- predict(best_model, n.ahead= weeks_ahead)

first_date <- time(series)[1]
last_date <- time(series)[length(time(series))]

ts.plot(ommitted_series, xlim=c(last_date - 52 / 52, last_date + weeks_ahead / 52), ylab="Snow depth (in)", main="Snow depth forecast")
U = fore$pred+fore$se; L = fore$pred-fore$se
xx = c(time(U), rev(time(U))); yy = c(L, rev(U))
polygon(xx, yy, border = 8, col = gray(.6, alpha = .2))
lines(fore$pred, type="o", col=2)
lines(detrended, lt="dashed",col=1)


# arima(detrended, order=c(1,1,1))

```

