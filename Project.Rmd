---
title: "STAT 221 Project"
author: "John Rapp Farnes | 405461225"
date: "3/5 2020"
output:
  pdf_document: default
  html_document: default
---
# TODO
- Long freq = smooth, variance long period
- Kommentera stora residualer? datum?
- Log: större skillnad större värden, plotta
- Periodogram residualer
- Model selection
- Prediction på known värden
- Tillbaka trend på pred

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(astsa)
library(imputeTS)
library(rjson)
library(forecast)
library(tseries)

data <- fromJSON(file = "./mammoth.json")
plot(data$depth, type="o", main="Raw data", ylab="Snow depth (in)")
```

```{r}
data$dates <- as.Date(data$dates, "%Y-%m-%d")

all_dates <- seq(data$dates[1], data$dates[length(data$dates)], by = "day")

length(data$dates) / length(all_dates)

all_depths <- rep(NA, length(all_dates))

for (date in intersect(data$dates, all_dates)) {
  all_depths[which(all_dates == date)] <- data$depth[which(data$dates == date)[1]]
}
```

```{r}
table(as.numeric(format.Date(data$date, "%m")), data$depth == 0)

all_depths[which(all_depths == 0)] <- NA
```

```{r}

data <- data.frame(date = all_dates, depth = all_depths)

nrow(data)

plot(data, type="o")
```

```{r}
(tab <- table(as.numeric(format.Date(data$date, "%m")), is.na(data$depth)))

plot(tab[, 1] / (tab[, 1] + tab[, 2]), type="o")
```

```{r}

mean_ignore_na <- function(x) {
  non_na <- x[which(!is.na(x))]
  return(ifelse(length(non_na) == 0, NA, mean(non_na)))
}

first_sat <- 3
last_sat <- length(data$date) - 2

week_length <- 7
nr_weeks <- (last_sat - first_sat) / week_length

week_start <- data$date[first_sat]
week_end <- data$date[last_sat]

weekly_depths <- mean_ignore_na(data$depth[1:first_sat])

# for(i in seq(from = first_sat, to = last_sat, by = week_length)) {
for (i in 2:(nr_weeks + 1)) {
  sunday <- (first_sat + 1) + (i - 2)*week_length
  saturday <- sunday + 6

  weekly_depths[i] <- mean_ignore_na(data$depth[sunday:saturday])
}

weeks <- seq(data$date[first_sat], data$date[last_sat], by=7)

data <- data.frame(
  depth = weekly_depths,
  date = weeks
)

plot(data$depth, type="o")
```

# Missing values
```{r}
data$depth[which(is.na(data$depth))] <- 0

(tab <- table(as.numeric(format.Date(data$date, "%m")), data$depth == 0))

month.labels <- format(ISOdatetime(2000,1:12,1,0,0,0),"%b")
barplot(tab[, 1] / (tab[, 1] + tab[, 2]), names.arg = month.labels, ylab="% available data", main="Available data by month")
```

```{r}
series <- ts(
  data$depth,
  start=c(as.numeric(format(data$date[1], "%Y")), as.numeric(format(data$date[1], "%U"))),
  # end=c(as.numeric(format(data$date[length(data$date)], "%Y")), as.numeric(format(data$date[length(data$date)], "%U"))),
  frequency=365.25/7
)
plot(series, main="Cleaned data", ylab="Snow depth (in)")
```


# ACF
```{r}
# acf(na_interpolation(series, option = "linear"), lag.max = 52 * 2)
# pacf(na_interpolation(series, option = "linear"), lag.max = 52 * 2)

acf(series, lag.max = 52 * 2)
pacf(series, lag.max = 52 * 2)
```

```{r}
pg <- mvspec(series, log="no")

k = kernel("daniell", c(1,1))
pg <- mvspec(series, kernel=k, log="no")

l <- 1/sum(k$coef^2)

alpha <- 0.05
U = qchisq(alpha/2, 2*l)
L = qchisq(1-alpha/2, 2*l)

max_index <- which(pg$spec == max(pg$spec))
freq <- pg$freq[max_index]

1/freq
conf <- l*c(2*pg$spec[max_index]/L,2*pg$spec[max_index]/U)
segments(x0=freq,y0=conf[1],x1=freq,y1=conf[2],col="blue")
segments(x0=freq-0.1,y0=conf[1],x1=freq+0.1,y1=conf[1],col="blue")

# abline(v=freq, col="blue")


max_index2 <- which(pg$spec == max(pg$spec[which(pg$freq < 0.5)]))
freq <- pg$freq[max_index2]

1/freq
conf <- l*c(2*pg$spec[max_index2]/L,2*pg$spec[max_index2]/U)
segments(x0=freq,y0=conf[1],x1=freq,y1=conf[2],col="red")
segments(x0=freq-0.1,y0=conf[1],x1=freq+0.1,y1=conf[1],col="red")
# abline(v=freq, col="red")
```

# Detrend
```{r}
lin.mod <- lm(series ~ time(series))
summary(lin.mod)

plot(series)
lines(series*0 + predict(lin.mod, time(series)), type="l", col="red")

detrended <- series - predict(lin.mod, time(series))

plot(detrended)

```

```{r}

# # periods <- as.numeric(format(data$date, "%V"))
# periods <- as.numeric(format(data$date, "%m"))
# 
# agg <- aggregate(
#   data$depth,
#   by=list(period = periods),
#   FUN=mean
# )
# 
# plot(agg$x, main="Monthly average snow depth", xaxt ="n", type="o", ylab="Snow depth (in)", xlab="")
# axis(1, at=1:12, labels=month.labels)
# 
# 
# detrended <- data$depth - agg$x[match(periods, agg$period)]
# 
# plot(data$depth, type="l", ylim=c(-100, 350))
# lines(detrended, type="l", col="red")
# 
# detrended <- ts(
#   detrended,
#   start=start(series),
#   end=end(series),
#   frequency=frequency(series)
# )
# plot(detrended, ylab="Snow depth (in)", main="Monthly average snow depth, detrended")
```


```{r}
# sum(is.na(data$depth) / length(data$depth))
# 
# (tab <- table(as.numeric(format.Date(data$date, "%m")), is.na(data$depth)))
# 
# plot(tab[, 1] / (tab[, 1] + tab[, 2]), type="o")
# 
# 
# plot(detrended)
# detrended <- na_interpolation(detrended, option = "linear")
# plot(detrended)
```

```{r}
plot(diff(detrended))
plot(diff(detrended, differences = 2))
acf(diff(detrended), lag.max = 52 * 2)
pacf(diff(detrended), lag.max = 52 * 2)

adf.test(detrended)
```


# Periodogram

```{r}
# TODO konfidens

pg <- mvspec(detrended, log="no")

k = kernel("daniell", c(1,1))
pg <- mvspec(detrended, kernel=k, log="no")

l <- 1/sum(k$coef^2)

alpha <- 0.05
U = qchisq(alpha/2, 2*l)
L = qchisq(1-alpha/2, 2*l)

max_index <- which(pg$spec == max(pg$spec))
freq <- pg$freq[max_index]

1/freq
conf <- l*c(2*pg$spec[max_index]/L,2*pg$spec[max_index]/U)
segments(x0=freq,y0=conf[1],x1=freq,y1=conf[2],col="blue")
segments(x0=freq-0.1,y0=conf[1],x1=freq+0.1,y1=conf[1],col="blue")

# abline(v=freq, col="blue")


max_index2 <- which(pg$spec == max(pg$spec[which(pg$freq > 4)]))
freq <- pg$freq[max_index2]

1/freq
conf <- l*c(2*pg$spec[max_index2]/L,2*pg$spec[max_index2]/U)
segments(x0=freq,y0=conf[1],x1=freq,y1=conf[2],col="red")
segments(x0=freq-0.1,y0=conf[1],x1=freq+0.1,y1=conf[1],col="red")
# abline(v=freq, col="red")
```

```{r}
pg <- spec.ar(detrended)

max_index <- which(pg$spec == max(pg$spec))
freq <- pg$freq[max_index]

1/freq
abline(v=freq,col="blue")


max_index2 <- which(pg$spec == max(pg$spec[which(pg$freq > 3)]))
freq <- pg$freq[max_index2]

1/freq
abline(v=freq,col="red")
```



# ACF
```{r}
acf(detrended, lag.max = 52 * 2)
pacf(detrended, lag.max = 52 * 2)
```

# Fit ARIMA

```{r}
# auto.arima(detrended)
# ARIMA(2,0,1)(1,1,0)[52]

# Coefficients:
#          ar1      ar2      ma1     sar1
#       1.7781  -0.7911  -0.5474  -0.5192
# s.e.  0.0679   0.0666   0.0923   0.0433
# 
# sigma^2 estimated as 148.9:  log likelihood=-1489.99
# AIC=2989.98   AICc=2990.14   BIC=3009.65

sarima(detrended, 2,0,1, 1,1,0, 1)
# sarima(detrended, 2,0,1, 1,1,1, 1)


## OFF PEAKS
# Best model: ARIMA(2,1,2)(1,0,0)[52]                    
# 
# Series: detrended 
# ARIMA(2,1,2)(1,0,0)[52] 
# 
# Coefficients:
#          ar1     ar2     ma1      ma2    sar1
#       0.0308  0.5816  -0.082  -0.4565  0.4746
# s.e.  0.1869  0.1543   0.202   0.1653  0.0445
# 
# sigma^2 estimated as 265.3:  log likelihood=-1814.17
# AIC=3640.35   AICc=3640.54   BIC=3664.73

sarima(detrended, 2,1,2, 1,0,1, 1)
sarima(detrended, 2,1,2, 1,1,0, 1)
```

```{r}
models <- list(
  arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,0), period=52))#,
  
  # arima(detrended, order=c(2,1,2), seasonal=list(order=c(1,0,1), period=52)),
  # # arima(detrended, order=c(2,1,1), seasonal=list(order=c(1,1,0), period=52))#,
  # # arima(detrended, order=c(3,1,2), seasonal=list(order=c(1,1,0), period=52))#,
  # # arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,1), period=52)),
  # # arima(detrended, order=c(3,0,3), seasonal=list(order=c(3,1,3), period=52))
  # # arima(detrended, order=c(2,0,1), seasonal=list(order=c(0,1,1), period=52))#,
  # # arima(detrended, order=c(2,0,1), seasonal=list(order=c(0,1,2), period=52))#,
  # # arima(detrended, order=c(3,1,2), seasonal=list(order=c(2,1,1), period=52)),
  # # arima(detrended, order=c(5,1,2)),
  # arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,0,0), period=52)),
  # arima(detrended, order=c(2,1,1), seasonal=list(order=c(1,0,0), period=52)),
  # arima(detrended, order=c(2,0,1), seasonal=list(order=c(2,0,0), period=52)),
  # arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,0), period=52)),
  # arima(detrended, order=c(2,0,1), seasonal=list(order=c(1,1,1), period=52)),
  
  # arima(detrended, order=c(2,1,1), seasonal=list(order=c(1,1,0), period=52))#,
  
  # arima(detrended, order=c(2,1,1), seasonal=list(order=c(1,0,1), period=52))#,
  # arima(detrended, order=c(5,0,5), seasonal=list(order=c(5,0,5), period=52)),
  # arima(detrended, order=c(5,0,5), seasonal=list(order=c(5,0,5), period=52)),
)

models

lapply(models, function(x) {
  return(x$aic)
})
```



```{r}
best_model <- models[[1]]

weeks_ahead <- 52
fore <- predict(best_model, n.ahead= weeks_ahead)

first_date <- time(series)[1]
last_date <- time(series)[length(time(series))]

ts.plot(detrended, fore$pred, col=1:2, xlim=c(last_date - 52 / 52, last_date + weeks_ahead / 52), ylab="Forecast")
U = fore$pred+fore$se; L = fore$pred-fore$se
xx = c(time(U), rev(time(U))); yy = c(L, rev(U))
polygon(xx, yy, border = 8, col = gray(.6, alpha = .2))
lines(fore$pred, type="p", col=2)

ts.plot(detrended, fore$pred, col=1:2, xlim=c(first_date,last_date + weeks_ahead / 52), ylab="Forecast")

U = fore$pred+fore$se; L = fore$pred-fore$se
xx = c(time(U), rev(time(U))); yy = c(L, rev(U))

polygon(xx, yy, border = 8, col = gray(.6, alpha = .2))
lines(fore$pred, type="p", col=2)

for (y in 0:8) {
  abline(v = last_date - y, lty="dashed", col="gray")
}


```
